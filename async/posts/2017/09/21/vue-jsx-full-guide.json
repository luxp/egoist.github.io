{"tags":[{"name":"vue","permalink":"https://egoist.moe/tags/vue/","url":"/async/tags/vue.json","count":4},{"name":"jsx","permalink":"https://egoist.moe/tags/jsx/","url":"/async/tags/jsx.json","count":1}],"categories":[],"url":"/async/posts/2017/09/21/vue-jsx-full-guide.json","date":1505967554000,"path":{"year":2017,"month":9,"day":21,"name":"vue-jsx-full-guide"},"subtitle":"JSX 相关专利归 NoFaceBoooooooooook 所有","title":"Vue JSX 使用指南","permalink":"https://egoist.moe/2017/09/21/vue-jsx-full-guide/","content":"<h2 id=\"什么是-jsx\">什么是 JSX?</h2>\n<p>没怎么使用 React 或类似框架的同学可能不太了解 JSX，对此我不做赘述，简而言之这就是一种对 JavaScript 的补充，用来描述组件的 UI 部分，类似模板语言但它完整支持 JavaScript 本身的语言特性。</p>\n<p>参考 FaceBook <a href=\"https://facebook.github.io/react/docs/introducing-jsx.html\" target=\"_blank\" rel=\"external\">关于 JSX 的介绍</a>。</p>\n<h2 id=\"转换-jsx\">转换 JSX</h2>\n<p>JSX 只是对 JavaScript 的补充并没有浏览器的支持，所以你需要用 <a href=\"http://babeljs.io/\" target=\"_blank\" rel=\"external\">Babel</a> 搭配 <a href=\"https://github.com/vuejs/babel-preset-vue\" target=\"_blank\" rel=\"external\">babel-preset-vue</a> 来获得完整的 Vue JSX 功能。</p>\n<h2 id=\"使用-jsx\">使用 JSX</h2>\n<h3 id=\"render-和-createelement-函数\">render 和 createElement 函数</h3>\n<p>你也许对 Vue 的 template (模板) 已经很熟悉了，如果你是用了 webpack + vue-loader 之类的组合，它其实是被转换成了 <code>render</code> 函数。</p>\n<p>对于以下单文件组件:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;{{ msg }}&lt;div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      msg: 'hello'\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<p>被 webpack + vue-loader 处理后是:</p>\n<pre><code class=\"language-js\">export default {\n  data() {\n    return {\n      msg: 'hello'\n    }\n  },\n  render() {\n    var _vm = this;\n    var _h = _vm.$createElement;\n    var _c = _vm._self._c || _h;\n    return _c('div', [_vm._v(_vm._s(_vm.msg)), _c('div')])\n  }\n}\n</code></pre>\n<p><small><em><a href=\"https://jsx.egoist.moe/gist/8a264502933118ee7afe811139bb52f6\" target=\"_blank\" rel=\"external\">在线调试</a></em></small></p>\n<p>这里的 <a href=\"https://vuejs.org/v2/guide/render-function.html#createElement-Arguments\" target=\"_blank\" rel=\"external\">createElement</a> 函数也经常被叫做 <code>h</code> 函数，它被用来创建一个 <a href=\"https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js\" target=\"_blank\" rel=\"external\">vNode</a> (虚拟 DOM 节点)。你可以通过 <code>this.$createElement</code> 访问它但同时它也是 <code>render</code> 函数的第一个参数。</p>\n<p>在使用 JSX 的时候，类似 template，不过只会转换 <code>render</code> 函数中的 JSX 表达式。</p>\n<p>对于以下源代码:</p>\n<pre><code class=\"language-jsx\">export default {\n  data() {\n    return {\n      msg: 'hello'\n    }\n  },\n  render() {\n    return &lt;div&gt;{this.msg}&lt;/div&gt;\n  }\n}\n</code></pre>\n<p>它会被转换成:</p>\n<pre><code class=\"language-js\">export default {\n  data() {\n    return {\n      msg: 'hello'\n    };\n  },\n  render() {\n    const h = arguments[0];\n\n    return h(\n      'div',\n      null,\n      [this.msg]\n    );\n  }\n};\n</code></pre>\n<p><small><em><a href=\"https://jsx.egoist.moe/gist/a2bda79dfa96053bc9bb5e743988796e\" target=\"_blank\" rel=\"external\">在线调试</a></em></small></p>\n<h2 id=\"vue-jsx-特性\">Vue JSX 特性</h2>\n<h3 id=\"和-react-jsx-的不同\">和 React JSX 的不同</h3>\n<p>Vue JSX 中 createElement 的第二个参数 <code>data</code> 与 React 中的有些不同，它是个嵌套的对象并且每个顶层的属性由不同的模块处理，提供不同的功能，比如 <code>class</code> (在 React 中是 <code>className</code>) 和 <code>on</code> 这两个属性:</p>\n<pre><code class=\"language-js\">createElement('div', {\n  class: ['foo', 'bar'],\n  on: {\n    click: this.click\n  },\n  ['foo']\n})\n</code></pre>\n<p>对应的 JSX 是:</p>\n<pre><code class=\"language-jsx\">&lt;div class=&quot;foo bar&quot; onClick={this.click}&gt;foo&lt;/div&gt;\n</code></pre>\n<p>对于这种嵌套对象，你可以在 JSX 中用 camelCase 或者 kebeb-case (连字符) 来表示，换句话说这里 JSX 中的 <code>onClick</code> 也可以写成 <code>on-click</code>，前者是为了让熟悉 React JSX 的同学更方便而加入的。</p>\n<p>完整的属性列表请参考相关 <a href=\"https://github.com/vuejs/vue/blob/2deda3d4328eb7aea0adb0eaf01d68537ed0e0af/types/vnode.d.ts#L36-L60\" target=\"_blank\" rel=\"external\">typing</a> 和 <a href=\"https://github.com/vuejs/babel-plugin-transform-vue-jsx#difference-from-react-jsx\" target=\"_blank\" rel=\"external\">README</a>。</p>\n<h3 id=\"v-model-sup-插件页面-sup\">v-model <sup><a href=\"https://github.com/nickmessing/babel-plugin-jsx-v-model\" target=\"_blank\" rel=\"external\">插件页面</a></sup></h3>\n<p>不久之前 Vue JSX 还不支持 <code>v-model</code> 因为这个转换比较复杂，感谢 <a href=\"https://github.com/nickmessing\" target=\"_blank\" rel=\"external\">@nickmessing</a> 的 <a href=\"https://github.com/nickmessing/babel-plugin-jsx-v-model\" target=\"_blank\" rel=\"external\">babel-plugin-jsx-v-model</a> 插件。</p>\n<p>对于以下 template:</p>\n<pre><code class=\"language-html\">&lt;input v-model=&quot;username&quot; &gt;\n</code></pre>\n<p>对应的 JSX 是:</p>\n<pre><code class=\"language-jsx\">&lt;input v-model={this.username} /&gt;\n</code></pre>\n<p>编译后:</p>\n<pre><code class=\"language-js\">import _mergeJSXProps from &quot;babel-helper-vue-jsx-merge-props&quot;;\n\nvar _this = this;\n\nh(\n  &quot;input&quot;,\n  _mergeJSXProps([{\n    domProps: {\n      &quot;value&quot;: _this.username\n    },\n    on: {\n      &quot;input&quot;: $event =&gt; {\n        if ($event.target.composing) return;\n        _this.username = $event.target.value;\n      }\n    }\n  }, {\n    directives: [{\n      name: &quot;model&quot;,\n      value: _this.username\n    }]\n  }]),\n  []\n);\n</code></pre>\n<p><small><em><a href=\"https://jsx.egoist.moe/gist/7de4ca46ae8eb69dbd861e23c4603f64\" target=\"_blank\" rel=\"external\">在线演示</a></em></small></p>\n<p>其实在 JSX 里的 <code>v-model</code> 就是语法糖，你当然可以手动书写对应的逻辑。而这个 Babel 插件则简化了这一步骤。JSX 中的 <code>v-model</code> 拥有 template 中同样的功能。</p>\n<h3 id=\"事件修饰符-sup-插件页面-sup\">事件修饰符 <sup><a href=\"https://github.com/nickmessing/babel-plugin-jsx-event-modifiers\" target=\"_blank\" rel=\"external\">插件页面</a></sup></h3>\n<p>template 中的键盘事件修饰符在 JSX 中也有完整的支持。</p>\n<p>对于以下 template:</p>\n<pre><code class=\"language-html\">&lt;input @keydown.enter=&quot;handleEnter&quot;&gt;\n&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;\n</code></pre>\n<p>对应的 JSX:</p>\n<pre><code class=\"language-jsx\">&lt;input onKeydown:enter={this.handleEnter}&gt;\n// 多个修饰符用 `-` 连字符连接\n&lt;a onClick:stop-prevent={this.doThat}&gt;Click&lt;/a&gt;\n</code></pre>\n<p>转换之后的 JS:</p>\n<pre><code class=\"language-js\">\nvar _this = this;\n\nh(\n  &quot;a&quot;,\n  {\n    on: {\n      &quot;click&quot;: $event =&gt; {\n        $event.stopPropagation();\n        $event.preventDefault();\n\n        _this.doThat($event);\n      }\n    }\n  },\n  [&quot;Click&quot;]\n);\n</code></pre>\n<p><small><em><a href=\"https://jsx.egoist.moe/gist/8b99c95854d389df4772e4b677966403\" target=\"_blank\" rel=\"external\">在线演示</a></em></small></p>\n<h3 id=\"functional-component-sup-插件页面-sup\">functional component <sup><a href=\"https://github.com/nickmessing/babel-plugin-jsx-vue-functional\" target=\"_blank\" rel=\"external\">插件页面</a></sup></h3>\n<p>在此之前 Vue 中的 functional component 还是只能用 object 的形式表达，这个插件支持将一个纯函数转换成 Vue functional component，就像 React 中那样:</p>\n<pre><code class=\"language-jsx\">const Message = ctx =&gt; (\n  &lt;div&gt;{ctx.props.message}&lt;/div&gt;\n)\n</code></pre>\n<p>转换后的 JS:</p>\n<pre><code class=\"language-js\">const Message = {\n  functional: true,\n  render: (h, ctx) =&gt; h(\n    &quot;div&quot;,\n    null,\n    [ctx.props.message]\n  )\n};\n</code></pre>\n<p><small><em><a href=\"https://jsx.egoist.moe/gist/d4d503e7cc605b258595beda4c975a6d\" target=\"_blank\" rel=\"external\">在线演示</a></em></small></p>\n"}