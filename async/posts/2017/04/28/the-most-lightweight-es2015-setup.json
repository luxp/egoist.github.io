{"tags":[{"name":"babel","permalink":"https://egoistian.com/tags/babel/","url":"/async/tags/babel.json","count":1},{"name":"buble","permalink":"https://egoistian.com/tags/buble/","url":"/async/tags/buble.json","count":1}],"categories":[],"url":"/async/posts/2017/04/28/the-most-lightweight-es2015-setup.json","date":1493385092000,"path":{"year":2017,"month":4,"day":28,"name":"the-most-lightweight-es2015-setup"},"subtitle":"Sometimes Babel, Sometimes Buble.","title":"最轻量的 ES2015 编译配置","permalink":"https://egoistian.com/2017/04/28/the-most-lightweight-es2015-setup/","content":"<h2 id=\"用-buble-替换-babel\">用 Buble 替换 Babel</h2>\n<p><a href=\"http://babeljs.io/\" target=\"_blank\" rel=\"external\">Babel</a> 可以说是编译 ES2015+ 代码到 ES5 的首要选择，它的可扩展性很高，基于插件几乎能做任何事。</p>\n<p>而 <a href=\"https://buble.surge.sh/guide/\" target=\"_blank\" rel=\"external\">Buble</a> 则去掉了这种可扩展性，只会转换能够用 ES5 实现并保证性能的新特性，同时这样也让你免去配置的步骤。</p>\n<p>对于下面这段代码，你可以通过编译结果看出它们设计上的不同:</p>\n<pre><code class=\"language-js\">class Foo {\n  constructor() {\n    this.pos = 0\n  }\n\n  say(word) {\n    return `hello ${world}`\n  }\n\n  walk() {\n    this.pos++\n  }\n}\n</code></pre>\n<p>Babel 的结果:</p>\n<pre><code class=\"language-js\">&quot;use strict&quot;;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&quot;Cannot call a class as a function&quot;); } }\n\nvar Foo = function () {\n  function Foo() {\n    _classCallCheck(this, Foo);\n\n    this.pos = 0;\n  }\n\n  _createClass(Foo, [{\n    key: &quot;say&quot;,\n    value: function say(word) {\n      return &quot;hello &quot; + world;\n    }\n  }, {\n    key: &quot;walk&quot;,\n    value: function walk() {\n      this.pos++;\n    }\n  }]);\n\n  return Foo;\n}();\n</code></pre>\n<p>Buble 的结果:</p>\n<pre><code class=\"language-js\">var Foo = function Foo() {\n  this.pos = 0\n};\n\nFoo.prototype.say = function say (word) {\n  return (&quot;hello &quot; + world)\n};\n\nFoo.prototype.walk = function walk () {\n  this.pos++\n};\n</code></pre>\n<p>总的来说 Buble 的结果可读性更强、更简洁，而且设计初衷就是为了不引入 <code>_createClass</code> 之类的 runtime。</p>\n<h2 id=\"async-await-和-generator-函数\">async/await 和 generator 函数</h2>\n<p>Buble 暂时不支持编译 async/await 和 generator 函数，目前有以下几个工具作为替代:</p>\n<ul>\n<li><a href=\"https://github.com/MatAtBread/nodent\" target=\"_blank\" rel=\"external\">nodent</a> (性能比 babel-plugin-tranform-async-to-generator 更好)</li>\n<li><a href=\"https://github.com/leebyron/async-to-gen\" target=\"_blank\" rel=\"external\">async-to-gen</a> (不支持编译 generator)</li>\n</ul>\n<p>我一般会将 Rollup、Buble 以及 async-to-gen 配合使用:</p>\n<pre><code class=\"language-js\">// rollup.config.js\nexport default {\n  plugins: [\n    require('rollup-plugin-async')(),\n    require('rollup-plugin-buble')()\n  ]\n}\n</code></pre>\n<p>其实由于在开发 web app 的时候基本还是用 webpack 为主而且又是对 ES features 的需求不止于 ES2015，这个时候我一般还是选择用 Babel 编译。</p>\n<p>而对于可复用的 library，不太需要 async/await 或者只是针对 Node.js 环境的时候，使用 Buble 还是很理想的。</p>\n"}